<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Complex Function Visualizer</title>
  <style>
      :root {
          --bg-color: #1e1e1e;
          --text-color: #dcdcdc;
          --border-color: #444;
          --panel-bg: #2a2a2a;
          --accent-color: #007acc;
          --font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
          --monospace-font: "Consolas", "Menlo", "Monaco", monospace;

          --error-text-color: #ff1717;
          --error-border-color: #d40000;
          --error-bg-color: #2e0000;

      }

      /* Light theme overrides */
      @media (prefers-color-scheme: light) {
          :root {
              --bg-color: #f8f9fa;
              --text-color: #212529;
              --border-color: #b7babc;
              --panel-bg: #ffffff;
              --input-bg: #ffffff;
              --info-label-color: #6c757d;

              --error-text-color: #ff0000;
              --error-border-color: #ff0000;
              --error-bg-color: #ffd8d8;
          }
      }

      *,
      *::before,
      *::after {
          transition: background-color 0.3s ease-in-out,
          color 0.3s ease-in-out,
          border-color 0.3s ease-in-out;
      }

      body {
          font-family: var(--font-family);
          background-color: var(--bg-color);
          color: var(--text-color);
          margin: 0;
          padding: 1.5rem;
          display: flex;
          flex-direction: column;
          align-items: center;
          min-height: 100vh;
      }

      h1 {
          color: var(--accent-color);
          margin-bottom: 1rem;
      }

      h2 {
          font-size: 1rem;
          font-weight: normal;
          text-align: center;
          margin: 0.5rem 0;
      }

      .main-container {
          display: flex;
          flex-direction: column;
          gap: 1.5rem;
          width: 100%;
          max-width: 1200px;
      }

      .plot-container {
          display: flex;
          justify-content: center;
          gap: 1.5rem;
          flex-wrap: wrap;
      }

      .plot-wrapper {
          display: flex;
          flex-direction: column;
          align-items: center;
      }

      canvas.plot-canvas {
          border: 1px solid var(--border-color);
          background-color: var(--bg-color);
          aspect-ratio: 1 / 1;
          width: 100%;
          max-width: 400px;
      }

      .controls-container {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 1.5rem;
          padding: 1.5rem;
          background-color: var(--panel-bg);
          border-radius: 8px;
          border: 1px solid var(--border-color);
      }

      .function-input-wrapper {
          grid-column: 1 / -1;
          display: flex;
          align-items: center;
          gap: 0.5rem;
      }

      .function-input-wrapper label {
          font-size: 1.2rem;
          font-family: var(--monospace-font);
      }

      .function-input-inner {
          flex-grow: 1;

          position: relative;
          display: flex;
          flex-direction: column;
          justify-content: stretch;
          align-items: stretch;
      }

      #error-panel {
          display: none;
          position: absolute;
          top: -1.5rem;
          padding: 0.25rem 0.75rem;
          font-size: 0.7rem;
          border: 1px solid var(--error-border-color);
          border-radius: 4px;
          background-color: var(--error-bg-color);
          color: var(--error-text-color);
      }

      #function-input {
          /*flex-grow: 1;*/
          /*width: 100%;*/
          padding: 0.75rem;
          font-size: 1.1rem;
          font-family: var(--monospace-font);
          background-color: var(--bg-color);
          color: var(--text-color);
          border: 1px solid var(--border-color);
          border-radius: 4px;
          outline: none;
      }
      #function-input:focus {
          border-color: var(--accent-color);
      }

      .legends-wrapper,
      .info-wrapper {
          display: flex;
          flex-direction: column;
          gap: 1rem;
      }

      .legend {
          display: flex;
          flex-direction: column;
          align-items: center;
      }

      .legend span {
          font-size: 0.9rem;
          margin-bottom: 0.5rem;
      }

      .legend canvas {
          border: 1px solid var(--border-color);
      }

      #info-panel {
          font-family: var(--monospace-font);
          font-size: 1rem;
          line-height: 1.6;
          background-color: var(--bg-color);
          padding: 0.7rem 1rem;
          border-radius: 4px;
          border: 1px solid var(--border-color);
          height: 100%;
          min-height: 120px;
      }
      #info-panel .label {
          color: var(--text-color);
      }
      #info-panel .value {
          color: var(--text-color);
          word-wrap: break-word;
      }

      @media (max-width: 800px) {
          .controls-container {
              grid-template-columns: 1fr;
          }
      }
  </style>
</head>
<body>
<div class="main-container">
  <h1>Complex Function Visualizer ðŸ“ˆ</h1>
  
  <div class="plot-container">
    <div class="plot-wrapper">
      <h2>Finite Domain (|z| < 2)</h2>
      <canvas
        id="finite-canvas"
        class="plot-canvas"
        width="400"
        height="400"
      ></canvas>
    </div>
    <div class="plot-wrapper">
      <h2>Neighborhood of Infinity (|z| > 8)</h2>
      <canvas
        id="infinity-canvas"
        class="plot-canvas"
        width="400"
        height="400"
      ></canvas>
    </div>
  </div>
  
  <div class="controls-container">
    <div class="function-input-wrapper">
      <label for="function-input">f(z) =</label>
      <div class="function-input-inner">
        <div id="error-panel"></div>
        <input type="text" id="function-input" value="z" />
      </div>
    </div>
    
    <div class="legends-wrapper">
      <div class="legend">
        <span>Argument (Hue)</span>
        <canvas
          id="arg-legend"
          width="256"
          height="30"
        ></canvas>
      </div>
      <div class="legend">
        <span>Modulus (Lightness)</span>
        <canvas
          id="mag-legend"
          width="256"
          height="30"
        ></canvas>
      </div>
    </div>
    
    <div class="info-wrapper">
      <div id="info-panel">
        <span>Values at Mouse Position</span><br />
        <span class="label">Plot:</span>
        <span id="info-location" class="value"></span><br />
        <span class="label">z =</span>
        <span id="info-z" class="value"></span><br />
        <span class="label">f(z) =</span>
        <span id="info-fz" class="value"></span><br />
        <span class="label">|f(z)| =</span>
        <span id="info-mag" class="value"></span><br />
        <span class="label">arg(f(z)) =</span>
        <span id="info-arg" class="value"></span>
      </div>
    </div>
  </div>
</div>

<script>
    // --- GLSL SHADER SOURCE ---
    // A single shader program is used for both canvases.
    // A uniform 'u_is_infinity_plot' differentiates between them.
    const vertexShaderSource = `
    attribute vec4 a_position;
    void main() {
        gl_Position = a_position;
    }
`;

    const fragmentShaderSource = `
    precision highp float;
    uniform vec2 u_resolution;
    uniform vec4 u_domain; // (xmin, xmax, ymin, ymax)
    uniform bool u_is_infinity_plot;

    // --- Complex Number Math Library (as vec2) ---
    const float PI = 3.14159265359;

    vec2 c_add(vec2 a, vec2 b) { return a + b; }
    vec2 c_sub(vec2 a, vec2 b) { return a - b; }
    vec2 c_mul(vec2 a, vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }
    vec2 c_inv(vec2 z) { float d = dot(z,z); return vec2(z.x, -z.y) / d; }
    vec2 c_div(vec2 a, vec2 b) { return c_mul(a, c_inv(b)); }
    vec2 c_pow(vec2 z, vec2 p) {
        float r = length(z);
        float theta = atan(z.y, z.x);
        float imag = p.x * theta + p.y * log(r);
        return pow(r, p.x) * exp(-p.y * theta) * vec2(cos(imag), sin(imag));
    }

    // --- User defined function f(z) ---
    // This part will be replaced by the parser's output
    // --- FUNCTION_PLACEHOLDER ---
    vec2 F_Z(vec2 z) {
        return z;
    }
    // --- END_FUNCTION_PLACEHOLDER ---

    // --- HSL to RGB Conversion ---
    vec3 hsl2rgb(vec3 c) {
        vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);
        return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
    }

    void main() {
        // Map pixel coordinates to complex plane coordinates
        vec2 st = gl_FragCoord.xy / u_resolution;
        vec2 z = vec2(
            u_domain.x + st.x * (u_domain.y - u_domain.x),
            u_domain.z + st.y * (u_domain.w - u_domain.z)
        );

        // For the infinity plot, the domain represents 1/z
        // So we just use z as is, which corresponds to plotting f(1/z)
        // For the finite plot, z is just z.
        
        // circle border for infinity plot
        float z2 = dot(z, z);
        if (u_is_infinity_plot && z2 > 0.125 * 0.125) {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            return;
        }

        // Handle poles gracefully
        if (u_is_infinity_plot && z.x == 0.0 && z.y == 0.0) {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // f(infinity) -> white
            return;
        }
        
        vec2 invz = vec2(z.x, -z.y) / z2;

        vec2 fz = u_is_infinity_plot ? F_Z(invz) : F_Z(z);

        // --- Domain Coloring ---
        // Hue from argument
        float hue = (atan(fz.y, fz.x) / (2.0 * PI)) + 0.5;

        float mag = length(fz);
        
        //float lightness = log(mag) / log(10.0) / 2.0;
        //lightness = clamp(lightness, 0.5, 1.0);
        float lightness = 0.5;

        float saturation = 0.9;

        vec3 rgb = hsl2rgb(vec3(hue, saturation, lightness));
        gl_FragColor = vec4(rgb, 1.0);
    }
`;

    // --- JAVASCRIPT LOGIC ---
    document.addEventListener("DOMContentLoaded", () => {
        // --- Element References ---
        const finiteCanvas = document.getElementById("finite-canvas");
        const infinityCanvas =
            document.getElementById("infinity-canvas");
        const funcInput = document.getElementById("function-input");
        const errorPanel = document.getElementById("error-panel");
        const infoLocation = document.getElementById("info-location");
        const infoZ = document.getElementById("info-z");
        const infoFz = document.getElementById("info-fz");
        const infoMag = document.getElementById("info-mag");
        const infoArg = document.getElementById("info-arg");

        // --- WebGL Setup ---
        const gl = finiteCanvas.getContext("webgl");
        const glInf = infinityCanvas.getContext("webgl");

        let webglProgram, webglProgramInf;
        let positionBuffer, positionBufferInf;

        // --- State ---
        const DOMAINS = {
            finite: { name: "Finite Domain", values: [-2, 2, -2, 2] },
            infinity: {
                name: "Infinity Neighborhood",
                values: [-0.125, 0.125, -0.125, 0.125],
            },
        };

        let jsFunction = (z) => z; // Default function in JS for info panel

        // --- Main Initialization ---
        function main() {
            // --- High DPI Setup ---
            const displaySize = 400; // The size defined in your CSS/HTML
            setupCanvasForHighDPI(finiteCanvas, displaySize);
            setupCanvasForHighDPI(infinityCanvas, displaySize);

            const buffer = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,]);
            positionBuffer = createAndFillBuffer(gl, buffer);
            positionBufferInf = createAndFillBuffer(glInf, buffer);

            funcInput.addEventListener("input", () =>
                debounce(updateAndRedraw, 100)(),
            );

            setupCanvasInteraction(finiteCanvas, DOMAINS.finite);
            setupCanvasInteraction(infinityCanvas, DOMAINS.infinity);

            drawLegends();
            updateAndRedraw();
        }

        function setupCanvasForHighDPI(canvas, desiredDisplaySize) {
            const dpr = window.devicePixelRatio || 1;

            // Set the canvas's drawing buffer size to match the physical pixels.
            canvas.width = desiredDisplaySize * dpr;
            canvas.height = desiredDisplaySize * dpr;

            // Set the canvas's display size in CSS pixels.
            canvas.style.width = desiredDisplaySize + 'px';
            canvas.style.height = desiredDisplaySize + 'px';
        }

        // --- Drawing & WebGL Logic ---
        function updateAndRedraw() {
            const funcStr = funcInput.value;
            const { glslCode, jsFunc, error } = parseFunction(funcStr);

            if (error) {
                funcInput.style.borderColor = "red";
                errorPanel.style.display = "block";
                errorPanel.innerText = error;
                console.error('ParseError:', error);
                return;
            } else {
                errorPanel.style.display = "none";
            }

            funcInput.style.borderColor = "var(--border-color)";
            jsFunction = jsFunc;

            const newFragmentShader = fragmentShaderSource.replace(
                /\/\/ --- FUNCTION_PLACEHOLDER ---[\s\S]*\/\/ --- END_FUNCTION_PLACEHOLDER ---/,
                glslCode,
            );

            webglProgram = createProgram(
                gl,
                vertexShaderSource,
                newFragmentShader,
            );
            webglProgramInf = createProgram(
                glInf,
                vertexShaderSource,
                newFragmentShader,
            );

            if (webglProgram && webglProgramInf) {
                drawScene(gl, webglProgram, DOMAINS.finite, false);
                drawScene(
                    glInf,
                    webglProgramInf,
                    DOMAINS.infinity,
                    true,
                );
            }
        }

        function drawScene(context, program, domain, isInfinity) {
            context.viewport(0, 0, context.canvas.width, context.canvas.height);
            context.useProgram(program);

            const positionLocation = context.getAttribLocation(
                program,
                "a_position",
            );
            context.bindBuffer(
                context.ARRAY_BUFFER,
                isInfinity ? positionBufferInf : positionBuffer,
            );
            context.enableVertexAttribArray(positionLocation);
            context.vertexAttribPointer(
                positionLocation,
                2,
                context.FLOAT,
                false,
                0,
                0,
            );

            const resolutionLocation = context.getUniformLocation(
                program,
                "u_resolution",
            );
            const domainLocation = context.getUniformLocation(
                program,
                "u_domain",
            );
            const isInfinityLocation = context.getUniformLocation(
                program,
                "u_is_infinity_plot",
            );

            context.uniform2f(
                resolutionLocation,
                context.canvas.width,
                context.canvas.height,
            );
            context.uniform4fv(domainLocation, domain.values);
            context.uniform1i(isInfinityLocation, isInfinity);

            context.drawArrays(context.TRIANGLES, 0, 6);
        }

        function drawLegends() {
            const argCanvas = document.getElementById("arg-legend");
            const magCanvas = document.getElementById("mag-legend");
            const argCtx = argCanvas.getContext("2d");
            const magCtx = magCanvas.getContext("2d");

            // Argument/Hue Legend
            for (let i = 0; i < argCanvas.width; i++) {
                const hue = (i / argCanvas.width) * 360;
                argCtx.fillStyle = `hsl(${hue}, 90%, 50%)`;
                argCtx.fillRect(i, 0, 1, argCanvas.height);
            }

            // Modulus/Lightness Legend
            const gradient = magCtx.createLinearGradient(
                0,
                0,
                magCanvas.width,
                0,
            );
            gradient.addColorStop(0, "#f00");
            gradient.addColorStop(0.75, "#f00");
            gradient.addColorStop(1, "#fff");
            magCtx.fillStyle = gradient;
            magCtx.fillRect(0, 0, magCanvas.width, magCanvas.height);
        }

        // --- User Interaction ---
        function setupCanvasInteraction(canvas, domain) {
            canvas.addEventListener("mousemove", (e) =>
                updateInfoPanel(e, canvas, domain),
            );
            canvas.addEventListener("mouseleave", clearInfoPanel);
        }

        function updateInfoPanel(event, canvas, domain) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const sx = x / canvas.clientWidth;
            const sy = 1.0 - y / canvas.clientHeight; // Y is inverted in web coords

            const domainRect = domain.values;
            const real =
                domainRect[0] + sx * (domainRect[1] - domainRect[0]);
            const imag =
                domainRect[2] + sy * (domainRect[3] - domainRect[2]);

            let z, z_display;
            if (domain.name === DOMAINS.infinity.name) {
                // The coordinate (real, imag) is actually 1/z. We need to calculate z.
                const one_over_z = { x: real, y: imag };
                z = complex.inv(one_over_z);
                z_display = one_over_z;
            } else {
                z = { x: real, y: imag };
                z_display = z;
            }

            const fz = jsFunction(z);
            const mag = complex.abs(fz);
            const arg = Math.atan2(fz.y, fz.x);

            infoLocation.textContent = domain.name;
            infoZ.textContent = formatComplex(
                domain.name === DOMAINS.infinity.name ? z : z_display,
                4,
            );
            infoFz.textContent = formatComplex(fz, 4);
            infoMag.textContent = mag.toExponential(4);
            infoArg.textContent = `${(arg / Math.PI).toFixed(4)} Ï€ rad`;
        }

        function clearInfoPanel() {
            infoLocation.textContent = "";
            infoZ.textContent = "";
            infoFz.textContent = "";
            infoMag.textContent = "";
            infoArg.textContent = "";
        }

        // --- Utilities ---
        function createAndFillBuffer(ctx, data) {
            const buffer = ctx.createBuffer();
            ctx.bindBuffer(ctx.ARRAY_BUFFER, buffer);
            ctx.bufferData(ctx.ARRAY_BUFFER, data, ctx.STATIC_DRAW);
            return buffer;
        }

        function createShader(ctx, type, source) {
            const shader = ctx.createShader(type);
            ctx.shaderSource(shader, source);
            ctx.compileShader(shader);
            if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)) {
                console.error(
                    "Shader compile error:",
                    ctx.getShaderInfoLog(shader),
                );
                ctx.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(ctx, vsSource, fsSource) {
            const vertexShader = createShader(
                ctx,
                ctx.VERTEX_SHADER,
                vsSource,
            );
            const fragmentShader = createShader(
                ctx,
                ctx.FRAGMENT_SHADER,
                fsSource,
            );
            if (!vertexShader || !fragmentShader) return null;

            const program = ctx.createProgram();
            ctx.attachShader(program, vertexShader);
            ctx.attachShader(program, fragmentShader);
            ctx.linkProgram(program);
            if (!ctx.getProgramParameter(program, ctx.LINK_STATUS)) {
                console.error(
                    "Program link error:",
                    ctx.getProgramInfoLog(program),
                );
                ctx.deleteProgram(program);
                return null;
            }
            return program;
        }

        function formatComplex(c, digits) {
            const sign = c.y < 0 ? "-" : "+";
            return `${c.x.toFixed(digits)} ${sign} ${Math.abs(c.y).toFixed(digits)}i`;
        }

        let debounceTimeout;
        function debounce(func, delay) {
            return (...args) => {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(
                    () => func.apply(this, args),
                    delay,
                );
            };
        }

        main();
    });

    // --- JS Complex Number Library (for info panel) ---
    const complex = {
        add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
        sub: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
        mul: (a, b) => ({
            x: a.x * b.x - a.y * b.y,
            y: a.x * b.y + a.y * b.x,
        }),
        inv: (z) => {
            const d = z.x * z.x + z.y * z.y;
            return { x: z.x / d, y: -z.y / d };
        },
        div: (a, b) => complex.mul(a, complex.inv(b)),
        abs: (z) => Math.sqrt(z.x * z.x + z.y * z.y),
        pow: (z, n) => {
            const r = complex.abs(z);
            const theta = Math.atan2(z.y, z.x);
            const rn = Math.pow(r, n);
            return {
                x: rn * Math.cos(n * theta),
                y: rn * Math.sin(n * theta),
            };
        },
    };

    // --- Simple Parser (Infix to GLSL and JS) ---
    // This is a simplified parser for demonstration. It supports z, numbers, +, -, *, /, ^.
    function parseFunction(str) {
        try {
            // Shunting-yard algorithm
            const ops = { "+": 1, "-": 1, "*": 2, "/": 2, "^": 3 };
            const opFuncs = {
                "+": { glsl: "c_add", js: "add" },
                "-": { glsl: "c_sub", js: "sub" },
                "*": { glsl: "c_mul", js: "mul" },
                "/": { glsl: "c_div", js: "div" },
                "^": { glsl: "c_pow", js: "pow" },
            };

            let outputQueue = [];
            let opStack = [];

            // Basic tokenization
            const tokens = str
                .replace(/\s+/g, "")
                .match(/z|\d+\.?\d*|[+\-*/^()]/g);
            if (!tokens)
                throw new Error("Invalid characters or empty function");

            for (const token of tokens) {
                if (token === "z" || !isNaN(parseFloat(token))) {
                    outputQueue.push(token);
                } else if (ops[token]) {
                    while (
                        opStack.length > 0 &&
                        ops[opStack[opStack.length - 1]] >= ops[token]
                        ) {
                        outputQueue.push(opStack.pop());
                    }
                    opStack.push(token);
                } else if (token === "(") {
                    opStack.push(token);
                } else if (token === ")") {
                    while (
                        opStack.length > 0 &&
                        opStack[opStack.length - 1] !== "("
                        ) {
                        outputQueue.push(opStack.pop());
                    }
                    if (opStack[opStack.length - 1] === "(") {
                        opStack.pop();
                    } else {
                        throw new Error("Mismatched parentheses");
                    }
                }
            }
            while (opStack.length > 0) {
                if (opStack[opStack.length - 1] === "(")
                    throw new Error("Mismatched parentheses");
                outputQueue.push(opStack.pop());
            }

            // Generate code from RPN (outputQueue)
            let glslStack = [];
            let jsStack = [];

            for (const token of outputQueue) {
                if (token === "z") {
                    glslStack.push("z");
                    jsStack.push("z");
                } else if (!isNaN(parseFloat(token))) {
                    glslStack.push(`vec2(${parseFloat(token)}, 0.0)`);
                    jsStack.push(`{x: ${parseFloat(token)}, y: 0.0}`);
                } else if (opFuncs[token]) {
                    const b_glsl = glslStack.pop();
                    const a_glsl = glslStack.pop();
                    const b_js = jsStack.pop();
                    const a_js = jsStack.pop();

                    if (opFuncs[token].glsl === "c_pow") {
                        glslStack.push(`c_pow(${a_glsl}, ${b_glsl})`);
                    } else {
                        glslStack.push(
                            `${opFuncs[token].glsl}(${a_glsl}, ${b_glsl})`,
                        );
                    }
                    jsStack.push(
                        `complex.${opFuncs[token].js}(${a_js}, ${b_js})`,
                    );
                }
            }

            if (glslStack.length !== 1 || jsStack.length !== 1)
                throw new Error("Invalid function syntax");

            const glslCode = `vec2 F_Z(vec2 z) { return ${glslStack[0]}; }`;
            const jsFunc = new Function("z", `return ${jsStack[0]}`);

            return { glslCode, jsFunc, error: null };
        } catch (e) {
            return { glslCode: null, jsFunc: null, error: e.message };
        }
    }
</script>
</body>
</html>
